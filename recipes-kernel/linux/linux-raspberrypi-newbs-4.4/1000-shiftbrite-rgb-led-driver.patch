From c3dc4ad912a3bd5b4447e79b782a05bdc042fbe1 Mon Sep 17 00:00:00 2001
From: Allen Wild <allenwild93@gmail.com>
Date: Sun, 29 Jan 2017 04:30:13 -0500
Subject: [PATCH 1/2] shiftbrite RGB LED driver

Holy shit, I wrote a kernel driver from scratch and it actually works.
Well, mostly at least. If I remove and re-insert this module, the system
will kernel panic some arbitrary time afterwards.
---
 arch/arm/boot/dts/overlays/Makefile                |   1 +
 .../dts/overlays/pi3-spi-shiftbrite-overlay.dts    |  34 ++++
 drivers/misc/Kconfig                               |   8 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/shiftbrite.c                          | 186 +++++++++++++++++++++
 5 files changed, 230 insertions(+)
 create mode 100644 arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
 create mode 100644 drivers/misc/shiftbrite.c

diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
index b13e34086ce5..b4ba5d787eb9 100644
--- a/arch/arm/boot/dts/overlays/Makefile
+++ b/arch/arm/boot/dts/overlays/Makefile
@@ -110,6 +110,7 @@ dtbo-$(RPI_DT_OVERLAYS) += vga666.dtbo
 dtbo-$(RPI_DT_OVERLAYS) += w1-gpio.dtbo
 dtbo-$(RPI_DT_OVERLAYS) += w1-gpio-pullup.dtbo
 dtbo-$(RPI_DT_OVERLAYS) += wittypi.dtbo
+dtbo-$(RPI_DT_OVERLAYS) += pi3-spi-shiftbrite.dtbo
 
 targets += dtbs dtbs_install
 targets += $(dtbo-y)
diff --git a/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts b/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
new file mode 100644
index 000000000000..1e27e2ede3d4
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
@@ -0,0 +1,34 @@
+/*
+ * Device Tree overlay for the Shiftbrite module
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+    compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709", "brcm,bcm2710";
+    /* disable spi-dev for spi0.0 & spi0.1 */
+    fragment@0 {
+        target = <&spi0>;
+        __overlay__ {
+            status = "okay";
+
+            spidev@0{
+                    status = "disabled";
+            };
+            spidev@1{
+                    status = "disabled";
+            };
+
+            shiftbrite@0 {
+                compatible = "shiftbrite";
+                reg = <0>;      /* CE0 */
+                #address-cells = <1>;
+                #size-cells = <0>;
+                spi-max-frequency = <500000>;
+                status = "okay";
+            };
+        };
+    };
+};
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index e7c274d8a935..c43f2a6e79da 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -158,6 +158,14 @@ config SGI_IOC4
 	  If you have an SGI Altix with an IOC4-based card say Y.
 	  Otherwise say N.
 
+config SHIFTBRITE
+	tristate "ShiftBrite SPI-controlled RGB LED"
+	depends on SPI
+	default n
+	help
+	    Driver to control ShiftBrite LEDs with a SPI bus, using the chip
+	    select GPIO to toggle the latch pin.
+
 config TIFM_CORE
 	tristate "TI Flash Media interface support"
 	depends on PCI
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 1acff5beaeda..0fb1e7a3e7af 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -58,3 +58,4 @@ obj-$(CONFIG_GENWQE)		+= genwqe/
 obj-$(CONFIG_ECHO)		+= echo/
 obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
 obj-$(CONFIG_CXL_BASE)		+= cxl/
+obj-$(CONFIG_SHIFTBRITE)	+= shiftbrite.o
diff --git a/drivers/misc/shiftbrite.c b/drivers/misc/shiftbrite.c
new file mode 100644
index 000000000000..1a84d552ca67
--- /dev/null
+++ b/drivers/misc/shiftbrite.c
@@ -0,0 +1,186 @@
+// here we go
+// GPL LICENSE HERE
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/spi/spi.h>
+
+#define RED24(value)    ((value & 0x00FF0000) >> 16)
+#define GREEN24(value)  ((value & 0x0000FF00) >> 8)
+#define BLUE24(value)    (value & 0x000000FF)
+
+#define RGB24_TO_RGB32(value)   ((BLUE24(value) << 20) | \
+                                 (RED24(value) << 10) | \
+                                 (GREEN24(value)))
+
+struct shiftbrite_chip {
+    u32                 value24; // 24-bit 0xRRGGBB value
+    struct spi_device   *spi;
+    struct mutex        lock;
+};
+
+// Internal Core Functions
+
+static void shiftbrite_set_latch(struct shiftbrite_chip *chip, int value)
+{
+    struct spi_device *spi = chip->spi;
+    if (gpio_is_valid(spi->cs_gpio))
+    {
+        //dev_info(&spi->dev, "spi.cs_gpio is valid. Setting latch/cs to %d\n", value);
+        gpio_set_value(spi->cs_gpio, value);
+    }
+    else
+    {
+        dev_err(&spi->dev, "unable to latch, spi.cs_gpio is not valid\n");
+    }
+}
+
+static int shiftbrite_write(struct shiftbrite_chip *chip)
+{
+    struct spi_device *spi = chip->spi;
+    u32 value32 = RGB24_TO_RGB32(chip->value24);
+    u8 buf[4];
+    struct spi_transfer xfer = {
+        .tx_buf     = buf,
+        .len        = 4,
+        .cs_change  = 0,
+    };
+    struct spi_message msg;
+    int ret = 0;
+
+    buf[0] = value32 >> 24;
+    buf[1] = (value32 & 0x00FF0000) >> 16;
+    buf[2] = (value32 & 0x0000FF00) >> 8;
+    buf[3] = (value32 & 0x000000FF);
+
+    spi_message_init(&msg);
+    spi_message_add_tail(&xfer, &msg);
+
+    ret = spi_sync(spi, &msg);
+    if (ret)
+    {
+        dev_err(&spi->dev, "spi_sync failed\n");
+        return ret;
+    }
+
+    shiftbrite_set_latch(chip, 1);
+    udelay(10);
+    shiftbrite_set_latch(chip, 0);
+
+    return ret;
+}
+
+// sysfs functions
+
+static ssize_t shiftbrite_sysfs_show_color(struct device *dev,
+                                           struct device_attribute *attr,
+                                           char *buf)
+{
+    struct shiftbrite_chip *chip = dev_get_drvdata(dev);
+    unsigned long value;
+
+    mutex_lock(&chip->lock);
+    value = chip->value24;
+    mutex_unlock(&chip->lock);
+
+    return sprintf(buf, "0x%06lx\n", value);
+}
+
+static ssize_t shiftbrite_sysfs_set_color(struct device *dev,
+                                          struct device_attribute *attr,
+                                          const char *buf, size_t count)
+{
+    struct shiftbrite_chip *chip = dev_get_drvdata(dev);
+    unsigned long value;
+    int err;
+
+    err = kstrtoul(buf, 16, &value);
+    if (err)
+        return err;
+
+    mutex_lock(&chip->lock);
+    chip->value24 = value;
+    shiftbrite_write(chip);
+    mutex_unlock(&chip->lock);
+
+    return count;
+}
+static DEVICE_ATTR(color, 0644, shiftbrite_sysfs_show_color, shiftbrite_sysfs_set_color);
+
+// Init/Exit Functions
+
+static int shiftbrite_probe(struct spi_device *spi)
+{
+    struct shiftbrite_chip *chip;
+    int ret;
+
+    spi->bits_per_word = 8;
+    spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
+
+    ret = spi_setup(spi);
+    if (ret < 0)
+        return ret;
+
+    chip = devm_kzalloc(&spi->dev, sizeof(struct shiftbrite_chip), GFP_KERNEL);
+    if (!chip)
+        return -ENOMEM;
+
+    spi_set_drvdata(spi, chip);
+    chip->spi = spi;
+    chip->value24 = 0;
+
+    mutex_init(&chip->lock);
+
+    ret = shiftbrite_write(chip);
+    if (ret)
+    {
+        dev_err(&spi->dev, "Failed writing: %d\n", ret);
+        goto exit_destroy;
+    }
+
+    ret = device_create_file(&spi->dev, &dev_attr_color);
+    if (ret)
+    {
+        dev_err(&spi->dev, "Failed to create sysfs file\n");
+        goto exit_destroy;
+    }
+
+    dev_info(&spi->dev, "Shiftbrite driver initialized");
+    return 0;
+
+exit_destroy:
+    mutex_destroy(&chip->lock);
+    return ret;
+}
+
+static int shiftbrite_remove(struct spi_device *spi)
+{
+    struct shiftbrite_chip *chip = spi_get_drvdata(spi);
+
+    device_remove_file(&spi->dev, &dev_attr_color);
+    mutex_destroy(&chip->lock);
+    spi_set_drvdata(spi, NULL);
+
+    kfree(chip);
+    dev_info(&spi->dev, "Shiftbrite driver unloaded\n");
+    return 0;
+}
+
+static struct spi_driver shiftbrite_spi_driver = {
+    .driver = {
+        .name = "shiftbrite",
+        .owner = THIS_MODULE
+    },
+    .probe  = shiftbrite_probe,
+    .remove = shiftbrite_remove,
+};
+module_spi_driver(shiftbrite_spi_driver);
+
+MODULE_AUTHOR("Allen Wild <allenwild93@gmail.com>");
+MODULE_DESCRIPTION("ShiftBrite SPI LED driver");
+MODULE_LICENSE("GPL");
-- 
2.11.0


From 254f96157fc0639733902c34b7f35ac787f69415 Mon Sep 17 00:00:00 2001
From: Allen Wild <allenwild93@gmail.com>
Date: Sun, 29 Jan 2017 22:15:58 -0500
Subject: [PATCH 2/2] shiftbrite: dt overlay tweaks

---
 .../dts/overlays/pi3-spi-shiftbrite-overlay.dts    | 28 ++++++++++++++++++----
 1 file changed, 23 insertions(+), 5 deletions(-)

diff --git a/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts b/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
index 1e27e2ede3d4..f21777bec661 100644
--- a/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
+++ b/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
@@ -7,7 +7,7 @@
 /plugin/;
 
 / {
-    compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709", "brcm,bcm2710";
+    compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
     /* disable spi-dev for spi0.0 & spi0.1 */
     fragment@0 {
         target = <&spi0>;
@@ -15,17 +15,35 @@
             status = "okay";
 
             spidev@0{
-                    status = "disabled";
+                status = "disabled";
             };
             spidev@1{
-                    status = "disabled";
+                status = "disabled";
             };
+        };
+    };
+
+    fragment@1 {
+        target = <&gpio>;
+        __overlay__ {
+            spi0_pins: spi0_pins {
+                brcm,pins = <8 9 10 11>;
+                brcm,function = <4>; /* alt0 */
+            };
+        };
+    };
+
+    fragment@2 {
+        target = <&spi0>;
+        __overlay__ {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            pinctrl-names = "default";
+            pinctrl-0 = <&spi0_pins>;
 
             shiftbrite@0 {
                 compatible = "shiftbrite";
                 reg = <0>;      /* CE0 */
-                #address-cells = <1>;
-                #size-cells = <0>;
                 spi-max-frequency = <500000>;
                 status = "okay";
             };
-- 
2.11.0

