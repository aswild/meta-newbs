From 454000a4a64e21198277a4573272eba9c22b318b Mon Sep 17 00:00:00 2001
From: Allen Wild <allenwild93@gmail.com>
Date: Sun, 29 Jan 2017 04:30:13 -0500
Subject: [PATCH] shiftbrite RGB LED driver

Holy shit, I wrote a kernel driver from scratch and it actually works.
Well, mostly at least. If I remove and re-insert this module, the system
will kernel panic some arbitrary time afterwards.
---
 arch/arm/boot/dts/overlays/Makefile                |   1 +
 .../dts/overlays/pi3-spi-shiftbrite-overlay.dts    |  34 ++++
 drivers/spi/Kconfig                                |   7 +
 drivers/spi/Makefile                               |   1 +
 drivers/spi/shiftbrite.c                           | 186 +++++++++++++++++++++
 5 files changed, 229 insertions(+)
 create mode 100644 arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
 create mode 100644 drivers/spi/shiftbrite.c

diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
index c50b1dfa9d73..765330d79549 100644
--- a/arch/arm/boot/dts/overlays/Makefile
+++ b/arch/arm/boot/dts/overlays/Makefile
@@ -68,6 +68,7 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
 	pi3-disable-bt.dtbo \
 	pi3-disable-wifi.dtbo \
 	pi3-miniuart-bt.dtbo \
+	pi3-spi-shiftbrite.dtbo \
 	piscreen.dtbo \
 	piscreen2r.dtbo \
 	pisound.dtbo \
diff --git a/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts b/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
new file mode 100644
index 000000000000..1e27e2ede3d4
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/pi3-spi-shiftbrite-overlay.dts
@@ -0,0 +1,34 @@
+/*
+ * Device Tree overlay for the Shiftbrite module
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+    compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709", "brcm,bcm2710";
+    /* disable spi-dev for spi0.0 & spi0.1 */
+    fragment@0 {
+        target = <&spi0>;
+        __overlay__ {
+            status = "okay";
+
+            spidev@0{
+                    status = "disabled";
+            };
+            spidev@1{
+                    status = "disabled";
+            };
+
+            shiftbrite@0 {
+                compatible = "shiftbrite";
+                reg = <0>;      /* CE0 */
+                #address-cells = <1>;
+                #size-cells = <0>;
+                spi-max-frequency = <500000>;
+                status = "okay";
+            };
+        };
+    };
+};
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 1761c9004fc1..cbe6d495743b 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -769,6 +769,13 @@ config SPI_LOOPBACK_TEST
 	  primarily used for development of spi_master drivers
 	  and to detect regressions
 
+config SPI_SHIFTBRITE
+	tristate "ShiftBrite SPI-controlled RGB LED"
+	default n
+	help
+	    Driver to control ShiftBrite LEDs with a SPI bus, using the chip
+	    select GPIO to toggle the latch pin.
+
 config SPI_TLE62X0
 	tristate "Infineon TLE62X0 (for power switching)"
 	depends on SYSFS
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index b375a7a89216..9f84ebf73aa1 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -88,6 +88,7 @@ obj-$(CONFIG_SPI_SH)			+= spi-sh.o
 obj-$(CONFIG_SPI_SH_HSPI)		+= spi-sh-hspi.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi-sh-msiof.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi-sh-sci.o
+obj-$(CONFIG_SPI_SHIFTBRITE)		+= shiftbrite.o
 obj-$(CONFIG_SPI_SIRF)		+= spi-sirf.o
 obj-$(CONFIG_SPI_ST_SSC4)		+= spi-st-ssc4.o
 obj-$(CONFIG_SPI_SUN4I)			+= spi-sun4i.o
diff --git a/drivers/spi/shiftbrite.c b/drivers/spi/shiftbrite.c
new file mode 100644
index 000000000000..1a84d552ca67
--- /dev/null
+++ b/drivers/spi/shiftbrite.c
@@ -0,0 +1,186 @@
+// here we go
+// GPL LICENSE HERE
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/spi/spi.h>
+
+#define RED24(value)    ((value & 0x00FF0000) >> 16)
+#define GREEN24(value)  ((value & 0x0000FF00) >> 8)
+#define BLUE24(value)    (value & 0x000000FF)
+
+#define RGB24_TO_RGB32(value)   ((BLUE24(value) << 20) | \
+                                 (RED24(value) << 10) | \
+                                 (GREEN24(value)))
+
+struct shiftbrite_chip {
+    u32                 value24; // 24-bit 0xRRGGBB value
+    struct spi_device   *spi;
+    struct mutex        lock;
+};
+
+// Internal Core Functions
+
+static void shiftbrite_set_latch(struct shiftbrite_chip *chip, int value)
+{
+    struct spi_device *spi = chip->spi;
+    if (gpio_is_valid(spi->cs_gpio))
+    {
+        //dev_info(&spi->dev, "spi.cs_gpio is valid. Setting latch/cs to %d\n", value);
+        gpio_set_value(spi->cs_gpio, value);
+    }
+    else
+    {
+        dev_err(&spi->dev, "unable to latch, spi.cs_gpio is not valid\n");
+    }
+}
+
+static int shiftbrite_write(struct shiftbrite_chip *chip)
+{
+    struct spi_device *spi = chip->spi;
+    u32 value32 = RGB24_TO_RGB32(chip->value24);
+    u8 buf[4];
+    struct spi_transfer xfer = {
+        .tx_buf     = buf,
+        .len        = 4,
+        .cs_change  = 0,
+    };
+    struct spi_message msg;
+    int ret = 0;
+
+    buf[0] = value32 >> 24;
+    buf[1] = (value32 & 0x00FF0000) >> 16;
+    buf[2] = (value32 & 0x0000FF00) >> 8;
+    buf[3] = (value32 & 0x000000FF);
+
+    spi_message_init(&msg);
+    spi_message_add_tail(&xfer, &msg);
+
+    ret = spi_sync(spi, &msg);
+    if (ret)
+    {
+        dev_err(&spi->dev, "spi_sync failed\n");
+        return ret;
+    }
+
+    shiftbrite_set_latch(chip, 1);
+    udelay(10);
+    shiftbrite_set_latch(chip, 0);
+
+    return ret;
+}
+
+// sysfs functions
+
+static ssize_t shiftbrite_sysfs_show_color(struct device *dev,
+                                           struct device_attribute *attr,
+                                           char *buf)
+{
+    struct shiftbrite_chip *chip = dev_get_drvdata(dev);
+    unsigned long value;
+
+    mutex_lock(&chip->lock);
+    value = chip->value24;
+    mutex_unlock(&chip->lock);
+
+    return sprintf(buf, "0x%06lx\n", value);
+}
+
+static ssize_t shiftbrite_sysfs_set_color(struct device *dev,
+                                          struct device_attribute *attr,
+                                          const char *buf, size_t count)
+{
+    struct shiftbrite_chip *chip = dev_get_drvdata(dev);
+    unsigned long value;
+    int err;
+
+    err = kstrtoul(buf, 16, &value);
+    if (err)
+        return err;
+
+    mutex_lock(&chip->lock);
+    chip->value24 = value;
+    shiftbrite_write(chip);
+    mutex_unlock(&chip->lock);
+
+    return count;
+}
+static DEVICE_ATTR(color, 0644, shiftbrite_sysfs_show_color, shiftbrite_sysfs_set_color);
+
+// Init/Exit Functions
+
+static int shiftbrite_probe(struct spi_device *spi)
+{
+    struct shiftbrite_chip *chip;
+    int ret;
+
+    spi->bits_per_word = 8;
+    spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
+
+    ret = spi_setup(spi);
+    if (ret < 0)
+        return ret;
+
+    chip = devm_kzalloc(&spi->dev, sizeof(struct shiftbrite_chip), GFP_KERNEL);
+    if (!chip)
+        return -ENOMEM;
+
+    spi_set_drvdata(spi, chip);
+    chip->spi = spi;
+    chip->value24 = 0;
+
+    mutex_init(&chip->lock);
+
+    ret = shiftbrite_write(chip);
+    if (ret)
+    {
+        dev_err(&spi->dev, "Failed writing: %d\n", ret);
+        goto exit_destroy;
+    }
+
+    ret = device_create_file(&spi->dev, &dev_attr_color);
+    if (ret)
+    {
+        dev_err(&spi->dev, "Failed to create sysfs file\n");
+        goto exit_destroy;
+    }
+
+    dev_info(&spi->dev, "Shiftbrite driver initialized");
+    return 0;
+
+exit_destroy:
+    mutex_destroy(&chip->lock);
+    return ret;
+}
+
+static int shiftbrite_remove(struct spi_device *spi)
+{
+    struct shiftbrite_chip *chip = spi_get_drvdata(spi);
+
+    device_remove_file(&spi->dev, &dev_attr_color);
+    mutex_destroy(&chip->lock);
+    spi_set_drvdata(spi, NULL);
+
+    kfree(chip);
+    dev_info(&spi->dev, "Shiftbrite driver unloaded\n");
+    return 0;
+}
+
+static struct spi_driver shiftbrite_spi_driver = {
+    .driver = {
+        .name = "shiftbrite",
+        .owner = THIS_MODULE
+    },
+    .probe  = shiftbrite_probe,
+    .remove = shiftbrite_remove,
+};
+module_spi_driver(shiftbrite_spi_driver);
+
+MODULE_AUTHOR("Allen Wild <allenwild93@gmail.com>");
+MODULE_DESCRIPTION("ShiftBrite SPI LED driver");
+MODULE_LICENSE("GPL");
-- 
2.14.1

