From d718440eafbdbde44cc245386eca544c7569c84e Mon Sep 17 00:00:00 2001
From: Allen Wild <allenwild93@gmail.com>
Date: Tue, 14 Mar 2017 01:02:48 -0400
Subject: [PATCH 13/17] neostrip: add initial ws2812 driver

It has some output, but is incorrect. Timing is probably wacky
---
 arch/arm/boot/dts/overlays/Makefile                |   2 +
 .../boot/dts/overlays/spi0-neostrip-overlay.dts    |  50 ++
 .../boot/dts/overlays/spi1-neostrip-overlay.dts    |  50 ++
 drivers/misc/Kconfig                               |   7 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/neostrip.c                            | 545 +++++++++++++++++++++
 6 files changed, 655 insertions(+)
 create mode 100644 arch/arm/boot/dts/overlays/spi0-neostrip-overlay.dts
 create mode 100644 arch/arm/boot/dts/overlays/spi1-neostrip-overlay.dts
 create mode 100644 drivers/misc/neostrip.c

diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
index 56b08dc2cc61..55bad67014ab 100644
--- a/arch/arm/boot/dts/overlays/Makefile
+++ b/arch/arm/boot/dts/overlays/Makefile
@@ -92,10 +92,12 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
 	spi-rtc.dtbo \
 	spi0-cs.dtbo \
 	spi0-hw-cs.dtbo \
+	spi0-neostrip.dtbo \
 	spi0-shiftbrite.dtbo \
 	spi1-1cs.dtbo \
 	spi1-2cs.dtbo \
 	spi1-3cs.dtbo \
+	spi1-neostrip.dtbo \
 	spi1-shiftbrite.dtbo \
 	spi2-1cs.dtbo \
 	spi2-2cs.dtbo \
diff --git a/arch/arm/boot/dts/overlays/spi0-neostrip-overlay.dts b/arch/arm/boot/dts/overlays/spi0-neostrip-overlay.dts
new file mode 100644
index 000000000000..9edb38b5e699
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/spi0-neostrip-overlay.dts
@@ -0,0 +1,50 @@
+/*
+ * Device Tree overlay for the neostrip module
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+    compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+    fragment@0 {
+        target = <&gpio>;
+        __overlay__ {
+            spi0_pins: spi0_pins {
+                // we only need the data pin
+                brcm,pins = <20>;
+                brcm,function = <4>; /* alt0 (spi mosi) */
+            };
+        };
+    };
+
+    fragment@1 {
+        target = <&spi0>;
+        __overlay__ {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            status = "okay";
+            pinctrl-names = "default";
+            pinctrl-0 = <&spi0_pins>;
+
+            /* disable spi-dev for spi0.0 & spi0.1 */
+            spidev@0 {
+                status = "disabled";
+            };
+            spidev@1 {
+                status = "disabled";
+            };
+
+            neostrip0: neostrip@0 {
+                compatible = "neostrip";
+                reg = <0>;      /* CE0 */
+                spi-max-frequency = <2400000>;
+                latch-gpio = <9>;
+                status = "okay";
+            };
+        };
+    };
+};
diff --git a/arch/arm/boot/dts/overlays/spi1-neostrip-overlay.dts b/arch/arm/boot/dts/overlays/spi1-neostrip-overlay.dts
new file mode 100644
index 000000000000..4ef65e478765
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/spi1-neostrip-overlay.dts
@@ -0,0 +1,50 @@
+/*
+ * Device Tree overlay for the neostrip module
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+    compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+    fragment@0 {
+        target = <&gpio>;
+        __overlay__ {
+            spi1_pins: spi1_pins {
+                // we only need the data pin
+                brcm,pins = <20>;
+                brcm,function = <4>; /* alt0 (spi mosi) */
+            };
+        };
+    };
+
+    fragment@1 {
+        target = <&spi1>;
+        __overlay__ {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            status = "okay";
+            pinctrl-names = "default";
+            pinctrl-0 = <&spi1_pins>;
+
+            /* disable spi-dev for spi1.0 & spi1.1 */
+            spidev@0 {
+                status = "disabled";
+            };
+            spidev@1 {
+                status = "disabled";
+            };
+
+            neostrip0: neostrip@0 {
+                compatible = "neostrip";
+                reg = <0>;      /* CE0 */
+                spi-max-frequency = <2400000>;
+                latch-gpio = <9>;
+                status = "okay";
+            };
+        };
+    };
+};
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index d8b59a8914cd..a83dc0928c3f 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -167,6 +167,13 @@ config SHIFTBRITE
 	    Driver to control ShiftBrite LEDs with a SPI bus, using the chip
 	    select GPIO to toggle the latch pin.
 
+config NEOSTRIP
+	tristate "WS2812 RGB LED driver (SPI hardware)"
+	depends on SPI
+	default n
+	help
+	    Driver to control "NeoPixel" RGB LEDs using SPI hardware
+
 config TIFM_CORE
 	tristate "TI Flash Media interface support"
 	depends on PCI
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 6549404e6e9b..b474e8c60773 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
 obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_PANEL)             += panel.o
 obj-$(CONFIG_SHIFTBRITE)	+= shiftbrite.o
+obj-$(CONFIG_NEOSTRIP)		+= neostrip.o
 
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_core.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_bugs.o
diff --git a/drivers/misc/neostrip.c b/drivers/misc/neostrip.c
new file mode 100644
index 000000000000..e6882e3292a0
--- /dev/null
+++ b/drivers/misc/neostrip.c
@@ -0,0 +1,545 @@
+/***********************************************************************
+ * WS2812 "NeoPixel" RGB LED driver
+ *
+ * Copyright (C) 2017 Allen Wild <allenwild93@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ ***********************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <asm/uaccess.h>
+
+// definitions
+
+#define NEOSTRIP_SPEED_HZ   2400000
+#define NEOSTRIP_PACKET_LEN 9
+#define NEOSTRIP_CHUNK_LEN  3
+
+struct neostrip_chip {
+    dev_t               devt;
+    struct device       *dev;
+    struct spi_device   *spi;
+    struct list_head    device_entry;
+
+    int                 in_use;
+    struct mutex        in_use_lock;
+
+    spinlock_t          lock;
+    u32                 color;    // 24-bit 0xRRGGBB value
+};
+
+// static globals
+
+#define N_NEOSTRIP_MINORS 8
+
+static DECLARE_BITMAP(minors, N_NEOSTRIP_MINORS);
+static LIST_HEAD(device_list);
+static DEFINE_MUTEX(device_list_lock);
+
+static int              neostrip_major; // dynamically allocated major number
+static struct class     *neostrip_class;
+
+
+// Internal Core Functions
+
+// Expand a nibble of val (upper or lower) from 00000000abcd to 1a01b01c01d0
+// Magic multiplication and masking from
+//  https://developer.mbed.org/users/JacobBramley/code/PixelArray/file/47802e75974e/neopixel.cpp
+static inline u16 neostrip_expand_nibble(u8 val, int upper)
+{
+    if (upper)
+        val = (val >> 4) & 0xf;
+    else
+        val = val & 0xf;
+
+    return 04444 |                  // 100100100100
+           ((val * 0x88) & 0x410) | // 0a00000c0000
+           ((val * 0x22) & 0x82);   // 0000b00000d0
+}
+
+// store the expanded representation of val into the first 3 bytes of dest
+static void neostrip_expand_chunk(u8 *dest, u8 val)
+{
+    u16 exp_low = neostrip_expand_nibble(val, 0);
+    u16 exp_upp = neostrip_expand_nibble(val, 1);
+
+    dest[0] = (exp_upp >> 4) & 0xff;
+    dest[1] = ((exp_upp << 4) & 0xf0) | ((exp_low >> 8) & 0x0f);
+    dest[2] = exp_low & 0xff;
+}
+
+// expand a 24-byte color to 9 bytes of ws2812 data
+static inline void neostrip_expand_color(u8 *dest, u32 color)
+{
+    neostrip_expand_chunk(&dest[0], (color >>  8) & 0xff); // green
+    neostrip_expand_chunk(&dest[3], (color >> 16) & 0xff); // red
+    neostrip_expand_chunk(&dest[6], (color >>  0) & 0xff); // blue
+}
+
+static int neostrip_write(struct neostrip_chip *chip)
+{
+    struct spi_device   *spi = chip->spi;
+    struct spi_message  msg;
+    u8                  buf[9*8]; // 3 SPI bits per color bit, 24 * 3 / 8 = 9
+    int                 i, ret = 0;
+    struct spi_transfer xfer = {
+        .tx_buf     = buf,
+        .len        = 9*8,
+        .speed_hz   = NEOSTRIP_SPEED_HZ,
+    };
+
+    dev_info(chip->dev, "writing 0x%06x\n", chip->color);
+
+    neostrip_expand_color(buf, chip->color);
+
+    //print_hex_dump(KERN_INFO, "neostrip buf: ", DUMP_PREFIX_OFFSET,
+                   //16, 1, buf, sizeof(buf), 0);
+
+    for (i = 1; i < 8; i++)
+    {
+        memcpy(&buf[i*9], &buf[0], 9);
+    }
+
+    spi_message_init(&msg);
+    spi_message_add_tail(&xfer, &msg);
+
+    ret = spi_sync(spi, &msg);
+    if (ret)
+    {
+        dev_err(chip->dev, "spi_sync failed (%d)\n", ret);
+    }
+
+    udelay(50);
+
+    return ret;
+}
+
+static int neostrip_set_color_from_str(struct neostrip_chip *chip, const char *buf)
+{
+    unsigned long value;
+    int err;
+
+    if (strncmp(buf, "refresh", 7))
+    {
+        err = kstrtoul(buf, 16, &value);
+        if (err)
+            return err;
+        err = 1;
+    }
+    else
+    {
+        err = 0;
+    }
+
+    dev_dbg(chip->dev, "set color from string '%s'\n", buf);
+
+    spin_lock(&chip->lock);
+    // err=1 means to update the value, otherwise just refresh it
+    if (err)
+        chip->color = value;
+    err = neostrip_write(chip);
+    spin_unlock(&chip->lock);
+
+    return err;
+}
+
+// sysfs functions
+
+static ssize_t neostrip_sysfs_show_color(struct device *dev,
+                                           struct device_attribute *attr,
+                                           char *buf)
+{
+    struct neostrip_chip    *chip = dev_get_drvdata(dev);
+    unsigned long           value;
+
+    spin_lock(&chip->lock);
+    value = chip->color;
+    spin_unlock(&chip->lock);
+
+    return sprintf(buf, "0x%06lx\n", value);
+}
+
+static ssize_t neostrip_sysfs_set_color(struct device *dev,
+                                          struct device_attribute *attr,
+                                          const char *buf, size_t count)
+{
+    struct neostrip_chip *chip = dev_get_drvdata(dev);
+    int err;
+
+    err = neostrip_set_color_from_str(chip, buf);
+    if (err)
+        return err;
+
+    return count;
+}
+static DEVICE_ATTR(color, 0644, neostrip_sysfs_show_color, neostrip_sysfs_set_color);
+
+// Array of sysfs attributes to be automatically created/removed
+static const struct device_attribute *neostrip_sysfs_attrs[] = {
+    &dev_attr_color,
+};
+
+// device node
+
+static int neostrip_cdev_open(struct inode *inode, struct file *fp)
+{
+    struct neostrip_chip    *chip;
+    int                     ret = -ENXIO;
+
+    // find the driver data
+    list_for_each_entry(chip, &device_list, device_entry)
+    {
+        if (chip->devt == inode->i_rdev)
+        {
+            ret = 0;
+            break;
+        }
+    }
+    if (ret)
+    {
+        pr_err("neostrip: device not found\n");
+        return ret;
+    }
+
+    mutex_lock(&chip->in_use_lock);
+    if (chip->in_use)
+    {
+        ret = -EBUSY;
+        goto out;
+    }
+
+    chip->in_use = 1;
+    fp->private_data = chip;
+    nonseekable_open(inode, fp);
+
+out:
+    mutex_unlock(&chip->in_use_lock);
+    return ret;
+}
+
+static int neostrip_cdev_release(struct inode *inode, struct file *fp)
+{
+    struct neostrip_chip *chip;
+
+    chip = fp->private_data;
+    fp->private_data = NULL;
+    mutex_lock(&chip->in_use_lock);
+    chip->in_use = 0;
+    mutex_unlock(&chip->in_use_lock);
+
+    return 0;
+}
+
+static ssize_t neostrip_cdev_read(struct file *fp, char *buf, size_t count, loff_t *offset)
+{
+    struct neostrip_chip    *chip;
+    u32                     value;
+    size_t                  len;
+    char                    tbuf[16];
+
+    chip = fp->private_data;
+
+    spin_lock(&chip->lock);
+    value = chip->color;
+    spin_unlock(&chip->lock);
+
+    len = snprintf(tbuf, sizeof(tbuf), "0x%06x\n", value);
+
+    if (*offset >= len)
+        return 0;
+    if (*offset + count > len)
+        count = len - *offset;
+
+    if (copy_to_user(buf, tbuf + *offset, count))
+        return -EFAULT;
+
+    *offset += count;
+    return count;
+}
+
+static ssize_t neostrip_cdev_write(struct file *fp, const char *buf, size_t size, loff_t *offset)
+{
+    struct neostrip_chip    *chip;
+    int                     ret;
+    char                    *tbuf;
+
+    chip = fp->private_data;
+
+    // copy to a temporary buffer so we can null-terminate the string
+    tbuf = kzalloc(size + 1, GFP_KERNEL);
+    if (tbuf == NULL)
+        return -ENOMEM;
+
+    ret = copy_from_user(tbuf, buf, size);
+    if (ret)
+    {
+        ret = -EFAULT;
+        goto out;
+    }
+    tbuf[size] = '\0';
+
+    ret = neostrip_set_color_from_str(chip, tbuf);
+
+out:
+    kfree(tbuf);
+    return (ret < 0) ? ret : size;
+}
+
+long neostrip_cdev_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+    struct neostrip_chip    *chip;
+    long                    ret = 0;
+    //u32                     value;
+
+    chip = fp->private_data;
+
+    switch (cmd)
+    {
+#if 0
+        case NEOSTRIP_IOC_HELLO:
+            pr_info("neostrip: ioctl hello with arg 0x%lX\n", arg);
+            break;
+
+        case NEOSTRIP_IOC_RCOLOR24:
+            ret = __put_user(chip->color, (__u32 __user *)arg);
+            break;
+
+        case NEOSTRIP_IOC_WCOLOR24:
+            ret = __get_user(value, (u32 __user *)arg);
+            if (!ret)
+            {
+                spin_lock(&chip->lock);
+                chip->color = value;
+                ret = neostrip_write(chip);
+                spin_unlock(&chip->lock);
+            }
+            break;
+#endif
+        default:
+            pr_err("neostrip: unknown ioctl\n");
+            ret = -ENOTTY;
+            break;
+    }
+    return ret;
+}
+
+static struct file_operations neostrip_cdev_fops = {
+    .open           = neostrip_cdev_open,
+    .release        = neostrip_cdev_release,
+    .read           = neostrip_cdev_read,
+    .write          = neostrip_cdev_write,
+    .unlocked_ioctl = neostrip_cdev_ioctl,
+};
+
+// Init/Exit Functions
+
+static const struct of_device_id neostrip_dt_ids[] = {
+    { .compatible = "neostrip" },
+    {},
+};
+MODULE_DEVICE_TABLE(of, neostrip_dt_ids);
+
+static int neostrip_probe(struct spi_device *spi)
+{
+    struct neostrip_chip    *chip;
+    struct device           *dev;
+    unsigned long           minor;
+    int                     sysfs_i, ret;
+
+    // verify DT compatible string
+    if (spi->dev.of_node && !of_match_device(neostrip_dt_ids, &spi->dev))
+    {
+        dev_err(&spi->dev, "buggy DT!\n");
+        WARN_ON(spi->dev.of_node && !of_match_device(neostrip_dt_ids, &spi->dev));
+    }
+
+    // allocate neostrip data
+    chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+    if (!chip)
+    {
+        dev_err(&spi->dev, "kzalloc failed\n");
+        ret = -ENOMEM;
+        goto fail;
+    }
+
+    // initialize  data
+    spi_set_drvdata(spi, chip);
+    chip->spi = spi;
+    chip->color = 0;
+    spin_lock_init(&chip->lock);
+    mutex_init(&chip->in_use_lock);
+    INIT_LIST_HEAD(&chip->device_entry);
+
+    // get a minor device number
+    mutex_lock(&device_list_lock);
+    minor = find_first_zero_bit(minors, N_NEOSTRIP_MINORS);
+    if (minor >= N_NEOSTRIP_MINORS)
+    {
+        dev_err(&spi->dev, "unable to get minor device number\n");
+        ret = -ENODEV;
+        mutex_unlock(&device_list_lock);
+        goto fail_dealloc;
+    }
+
+    // create device node
+    chip->devt = MKDEV(neostrip_major, minor);
+    chip->dev = device_create(neostrip_class, &spi->dev, chip->devt, chip, "neostrip%lu", minor);
+    if (IS_ERR(chip->dev))
+    {
+        dev_err(&spi->dev, "device_create() failed\n");
+        ret = PTR_ERR_OR_ZERO(dev);
+        mutex_unlock(&device_list_lock);
+        goto fail_dealloc;
+    }
+
+    // add device to the list
+    set_bit(minor, minors);
+    list_add(&chip->device_entry, &device_list);
+
+    mutex_unlock(&device_list_lock);
+
+    // create sysfs files
+    for (sysfs_i = 0; sysfs_i < sizeof(neostrip_sysfs_attrs)/sizeof(neostrip_sysfs_attrs[0]); sysfs_i++)
+    {
+        ret = device_create_file(chip->dev, neostrip_sysfs_attrs[sysfs_i]);
+        if (ret)
+        {
+            dev_err(chip->dev, "Failed to create sysfs file %s\n", neostrip_sysfs_attrs[sysfs_i]->attr.name);
+            ret = -EFAULT;
+            goto fail_destroy_sysfs;
+        }
+    }
+
+    // Set up SPI
+    spi->bits_per_word = 8;
+    spi->mode = SPI_MODE_0 | SPI_NO_CS;
+
+    ret = spi_setup(spi);
+    if (ret < 0)
+    {
+        dev_err(chip->dev, "spi_setup failed\n");
+        goto fail_destroy_sysfs;
+    }
+
+    // Done!
+    dev_info(chip->dev, "neostrip driver initialized\n");
+    return 0;
+
+fail_destroy_sysfs:
+    for (sysfs_i--; sysfs_i >= 0; sysfs_i--)
+        device_remove_file(chip->dev, neostrip_sysfs_attrs[sysfs_i]);
+
+//fail_device_destroy:
+    mutex_lock(&device_list_lock);
+    list_del(&chip->device_entry);
+    device_destroy(neostrip_class, chip->devt);
+    clear_bit(MINOR(chip->devt), minors);
+    mutex_unlock(&device_list_lock);
+
+fail_dealloc:
+    spi_set_drvdata(spi, NULL);
+    kfree(chip);
+
+fail:
+    dev_err(&spi->dev, "neostrip initialization failed (%d)\n", ret);
+    return ret;
+}
+
+static int neostrip_remove(struct spi_device *spi)
+{
+    struct neostrip_chip *chip = spi_get_drvdata(spi);
+    int i;
+
+    for (i = 0; i < sizeof(neostrip_sysfs_attrs)/sizeof(neostrip_sysfs_attrs[0]); i++)
+        device_remove_file(chip->dev, neostrip_sysfs_attrs[i]);
+
+    spin_lock_irq(&chip->lock);
+    chip->spi = NULL;
+    spin_unlock_irq(&chip->lock);
+
+    mutex_lock(&device_list_lock);
+    list_del(&chip->device_entry);
+    device_destroy(neostrip_class, chip->devt);
+    clear_bit(MINOR(chip->devt), minors);
+    mutex_unlock(&device_list_lock);
+
+    spi_set_drvdata(spi, NULL);
+    kfree(chip);
+    dev_info(&spi->dev, "neostrip driver unloaded\n");
+    return 0;
+}
+
+static struct spi_driver neostrip_spi_driver = {
+    .driver = {
+        .name = "neostrip",
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(neostrip_dt_ids),
+    },
+    .probe  = neostrip_probe,
+    .remove = neostrip_remove,
+};
+
+static int __init neostrip_init(void)
+{
+    int ret;
+
+    // get a major device number
+    neostrip_major = register_chrdev(0, "neostrip", &neostrip_cdev_fops);
+    if (neostrip_major < 0)
+        return neostrip_major;
+
+    // create neostrip class
+    neostrip_class = class_create(THIS_MODULE, "neostrip");
+    if (IS_ERR(neostrip_class))
+    {
+        pr_err("%s: class_create() failed\n", __func__);
+        ret = -1;
+        goto fail_unregister;
+    }
+
+    // register the SPI protocol driver
+    ret = spi_register_driver(&neostrip_spi_driver);
+    if (ret < 0)
+    {
+        pr_err("%s: spi_register_driver() failed\n", __func__);
+        goto fail_class_destroy;
+    }
+
+    return 0;
+
+fail_class_destroy:
+    class_destroy(neostrip_class);
+fail_unregister:
+    unregister_chrdev(neostrip_major, "neostrip");
+    return ret;
+}
+module_init(neostrip_init);
+
+static void __exit neostrip_exit(void)
+{
+    spi_unregister_driver(&neostrip_spi_driver);
+    class_destroy(neostrip_class);
+    unregister_chrdev(neostrip_major, "neostrip");
+}
+module_exit(neostrip_exit);
+
+MODULE_AUTHOR("Allen Wild <allenwild93@gmail.com>");
+MODULE_DESCRIPTION("WS2812 NeoPixel RGB LED driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("spi:neostrip");
-- 
2.12.0

