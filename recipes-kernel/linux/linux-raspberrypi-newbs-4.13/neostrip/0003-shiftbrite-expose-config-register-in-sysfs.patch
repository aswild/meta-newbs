From c8195dc72a8085def4be6aa29ea774c882ad3cc0 Mon Sep 17 00:00:00 2001
From: Allen Wild <allenwild93@gmail.com>
Date: Mon, 20 Feb 2017 21:45:17 -0500
Subject: [PATCH 03/19] shiftbrite: expose config register in sysfs

---
 drivers/spi/shiftbrite.c | 166 +++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 147 insertions(+), 19 deletions(-)

diff --git a/drivers/spi/shiftbrite.c b/drivers/spi/shiftbrite.c
index 1a84d552ca67..df4717f485f6 100644
--- a/drivers/spi/shiftbrite.c
+++ b/drivers/spi/shiftbrite.c
@@ -1,5 +1,17 @@
-// here we go
-// GPL LICENSE HERE
+/***********************************************************************
+ * Shiftbrite SPI RGB LED Driver
+ *
+ * Copyright (C) 2017 Allen Wild <allenwild93@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ ***********************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -14,12 +26,37 @@
 #define GREEN24(value)  ((value & 0x0000FF00) >> 8)
 #define BLUE24(value)    (value & 0x000000FF)
 
+// When setting PWM values:
+//      bits 31-30 = 0
+//      bits 29-20 = blue
+//      bits 19-10 = red
+//      bits 09-00 = green
+//
+// When setting the config register (7-bit correction offsets)
+//      bit     31 = don't care
+//      bit     30 = 1
+//      bits 29-27 = reserved
+//      bits 26-20 = blue offset
+//      bits 19-17 = don't care
+//      bits 16-10 = red offset
+//      bit     09 = don't care
+//      bits 08-07 = clock mode (0 for shiftbrite chip)
+//      bits 06-00 = green offset
+
+#define COLOR_MASK      0x3FFFFFFF
+#define CONFIG_MASK     0x07F1FC7F
+
 #define RGB24_TO_RGB32(value)   ((BLUE24(value) << 20) | \
                                  (RED24(value) << 10) | \
                                  (GREEN24(value)))
 
+#define RGB24_TO_COLOR(value)   (RGB24_TO_RGB32(value) & COLOR_MASK)
+#define RGB24_TO_CONFIG(value)  (0x40000000 | (RGB24_TO_RGB32(value) & CONFIG_MASK))
+
 struct shiftbrite_chip {
-    u32                 value24; // 24-bit 0xRRGGBB value
+    u32                 value24;    // 24-bit 0xRRGGBB value
+    u32                 config24;   // Control register which holds scaling values
+                                    // Stored as a 24-bit 0xRRGGBB value
     struct spi_device   *spi;
     struct mutex        lock;
 };
@@ -40,10 +77,9 @@ static void shiftbrite_set_latch(struct shiftbrite_chip *chip, int value)
     }
 }
 
-static int shiftbrite_write(struct shiftbrite_chip *chip)
+static int shiftbrite_write_u32(struct shiftbrite_chip *chip, u32 value)
 {
     struct spi_device *spi = chip->spi;
-    u32 value32 = RGB24_TO_RGB32(chip->value24);
     u8 buf[4];
     struct spi_transfer xfer = {
         .tx_buf     = buf,
@@ -53,10 +89,12 @@ static int shiftbrite_write(struct shiftbrite_chip *chip)
     struct spi_message msg;
     int ret = 0;
 
-    buf[0] = value32 >> 24;
-    buf[1] = (value32 & 0x00FF0000) >> 16;
-    buf[2] = (value32 & 0x0000FF00) >> 8;
-    buf[3] = (value32 & 0x000000FF);
+    dev_info(&spi->dev, "writing 0x%08x\n", value);
+
+    buf[0] = value >> 24;
+    buf[1] = (value & 0x00FF0000) >> 16;
+    buf[2] = (value & 0x0000FF00) >> 8;
+    buf[3] = (value & 0x000000FF);
 
     spi_message_init(&msg);
     spi_message_add_tail(&xfer, &msg);
@@ -68,6 +106,7 @@ static int shiftbrite_write(struct shiftbrite_chip *chip)
         return ret;
     }
 
+    udelay(10);
     shiftbrite_set_latch(chip, 1);
     udelay(10);
     shiftbrite_set_latch(chip, 0);
@@ -75,6 +114,16 @@ static int shiftbrite_write(struct shiftbrite_chip *chip)
     return ret;
 }
 
+static inline int shiftbrite_write(struct shiftbrite_chip *chip)
+{
+    return shiftbrite_write_u32(chip, RGB24_TO_COLOR(chip->value24));
+}
+
+static inline int shiftbrite_write_config(struct shiftbrite_chip *chip)
+{
+    return shiftbrite_write_u32(chip, RGB24_TO_CONFIG(chip->config24));
+}
+
 // sysfs functions
 
 static ssize_t shiftbrite_sysfs_show_color(struct device *dev,
@@ -99,12 +148,22 @@ static ssize_t shiftbrite_sysfs_set_color(struct device *dev,
     unsigned long value;
     int err;
 
-    err = kstrtoul(buf, 16, &value);
-    if (err)
-        return err;
+    if (strncmp(buf, "refresh", 7))
+    {
+        err = kstrtoul(buf, 16, &value);
+        if (err)
+            return err;
+        err = 1;
+    }
+    else
+    {
+        err = 0;
+    }
 
     mutex_lock(&chip->lock);
-    chip->value24 = value;
+    // err=1 means to update the value, otherwise just refresh it
+    if (err)
+        chip->value24 = value;
     shiftbrite_write(chip);
     mutex_unlock(&chip->lock);
 
@@ -112,12 +171,63 @@ static ssize_t shiftbrite_sysfs_set_color(struct device *dev,
 }
 static DEVICE_ATTR(color, 0644, shiftbrite_sysfs_show_color, shiftbrite_sysfs_set_color);
 
+static ssize_t shiftbrite_sysfs_show_config(struct device *dev,
+                                            struct device_attribute *attr,
+                                            char *buf)
+{
+    struct shiftbrite_chip *chip = dev_get_drvdata(dev);
+    unsigned long value;
+
+    mutex_lock(&chip->lock);
+    value = chip->config24;
+    mutex_unlock(&chip->lock);
+
+    return sprintf(buf, "0x%06lx\n", value);
+}
+
+static ssize_t shiftbrite_sysfs_set_config(struct device *dev,
+                                           struct device_attribute *attr,
+                                           const char *buf, size_t count)
+{
+    struct shiftbrite_chip *chip = dev_get_drvdata(dev);
+    unsigned long value;
+    int err;
+
+    if (strncmp(buf, "refresh", 7))
+    {
+        err = kstrtoul(buf, 16, &value);
+        if (err)
+            return err;
+        err = 1;
+    }
+    else
+    {
+        err = 0;
+    }
+
+    mutex_lock(&chip->lock);
+    // err=1 means to update the value, otherwise just refresh it
+    if (err)
+        chip->config24 = value;
+    shiftbrite_write_config(chip);
+    mutex_unlock(&chip->lock);
+
+    return count;
+}
+static DEVICE_ATTR(config, 0644, shiftbrite_sysfs_show_config, shiftbrite_sysfs_set_config);
+
+// Array of sysfs attributes to be automatically created/removed
+static const struct device_attribute *shiftbrite_sysfs_attrs[] = {
+    &dev_attr_color,
+    &dev_attr_config
+};
+
 // Init/Exit Functions
 
 static int shiftbrite_probe(struct spi_device *spi)
 {
     struct shiftbrite_chip *chip;
-    int ret;
+    int i, ret;
 
     spi->bits_per_word = 8;
     spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
@@ -136,23 +246,38 @@ static int shiftbrite_probe(struct spi_device *spi)
 
     mutex_init(&chip->lock);
 
-    ret = shiftbrite_write(chip);
+    ret = shiftbrite_write_config(chip);
     if (ret)
     {
-        dev_err(&spi->dev, "Failed writing: %d\n", ret);
+        dev_err(&spi->dev, "Failed writing config: %d\n", ret);
         goto exit_destroy;
     }
 
-    ret = device_create_file(&spi->dev, &dev_attr_color);
+    ret = shiftbrite_write(chip);
     if (ret)
     {
-        dev_err(&spi->dev, "Failed to create sysfs file\n");
+        dev_err(&spi->dev, "Failed writing: %d\n", ret);
         goto exit_destroy;
     }
 
+    for (i = 0; i < sizeof(shiftbrite_sysfs_attrs)/sizeof(shiftbrite_sysfs_attrs[0]); i++)
+    {
+        ret = device_create_file(&spi->dev, shiftbrite_sysfs_attrs[i]);
+        if (ret)
+        {
+            dev_err(&spi->dev, "Failed to create sysfs file %s\n", shiftbrite_sysfs_attrs[i]->attr.name);
+            goto exit_remove_sysfs;
+        }
+    }
+
     dev_info(&spi->dev, "Shiftbrite driver initialized");
     return 0;
 
+exit_remove_sysfs:
+    // if errors, unload all previous sysfs files
+    for (i--; i >= 0; i--)
+        device_remove_file(&spi->dev, shiftbrite_sysfs_attrs[i]);
+
 exit_destroy:
     mutex_destroy(&chip->lock);
     return ret;
@@ -161,8 +286,11 @@ static int shiftbrite_probe(struct spi_device *spi)
 static int shiftbrite_remove(struct spi_device *spi)
 {
     struct shiftbrite_chip *chip = spi_get_drvdata(spi);
+    int i;
+
+    for (i = 0; i < sizeof(shiftbrite_sysfs_attrs)/sizeof(shiftbrite_sysfs_attrs[0]); i++)
+        device_remove_file(&spi->dev, shiftbrite_sysfs_attrs[i]);
 
-    device_remove_file(&spi->dev, &dev_attr_color);
     mutex_destroy(&chip->lock);
     spi_set_drvdata(spi, NULL);
 
-- 
2.14.2

